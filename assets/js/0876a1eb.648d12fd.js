"use strict";(self.webpackChunkmaptaskr_docs_copy=self.webpackChunkmaptaskr_docs_copy||[]).push([[1971],{19230:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(74848),r=n(28453);const a={title:"Tutorials | Dynamics 365 Add Search Polygon Function | Configuring Custom JS",sidebar_label:"Configuring Custom JS"},i="Configuring Custom.JS",s={id:"tutorials/maptaskr-for-dynamics-365-add-search-polygon/configuring-custom-js",title:"Tutorials | Dynamics 365 Add Search Polygon Function | Configuring Custom JS",description:"Before we begin changing anything, please familiarise yourself with how to create your own Custom.JS by following this link Custom CSS & JavaScript.",source:"@site/docs/tutorials/maptaskr-for-dynamics-365-add-search-polygon/configuring-custom-js.md",sourceDirName:"tutorials/maptaskr-for-dynamics-365-add-search-polygon",slug:"/tutorials/maptaskr-for-dynamics-365-add-search-polygon/configuring-custom-js",permalink:"/docs/tutorials/maptaskr-for-dynamics-365-add-search-polygon/configuring-custom-js",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Tutorials | Dynamics 365 Add Search Polygon Function | Configuring Custom JS",sidebar_label:"Configuring Custom JS"},sidebar:"maptaskrSidebar",previous:{title:"Introduction",permalink:"/docs/tutorials/maptaskr-for-dynamics-365-add-search-polygon/introduction"},next:{title:"Frequently Asked Questions",permalink:"/docs/faq/"}},l={},c=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"configuring-customjs",children:"Configuring Custom.JS"}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["Before we begin changing anything, please familiarise yourself with how to create your own Custom.JS by following this link ",(0,o.jsx)(t.a,{href:"/docs/dynamics-365/installation-guide/advanced-configuration-and-capability#custom-css--javascript",children:"Custom CSS & JavaScript"}),".\nWe will also be utilising the ",(0,o.jsx)(t.a,{href:"/docs/dynamics-365/registerable-events/map-interaction-events#featuresselected",children:"Features Selected"})," event."]})}),"\n",(0,o.jsx)(t.p,{children:"Below is a snippet of the Custom.JS code for your reference:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'/* place your custom JS Code here. */\nconst onValidateFailErrorMessage = \'Please upload a file or draw a shape\'; //error message to display when the map validation errors\nconst onUploadFailErrorMessage = \'Something has gone wrong during submission, please check your connection and try again.\';\nconst onIntersectionMessage = \'Intersections / Exclusions have been found, please check your shapes and try again.\';\n\nasync function clientValidationFunction(executionContext, controlId) {\n\t//user defined validation function, can use the following for getting the list of shapes, annotations and uploaded files.\n\t//if the user needs to fix the shapes, throw an error.\n\n\tconsole.log(\'Validating shapes with:\');\n\tconsole.log(executionContext);\n\tconsole.log(controlId);\n\n\tlet maptaskrControl = globalThis && globalThis.top && globalThis.top.maptaskrCORE && globalThis.top.maptaskrCORE[controlId];\n\tif (!maptaskrControl) {\n\t\tconsole.error(\'Maptaskr Control not found\');\n\t\treturn;\n\t}\n\n\t//let shapes = _getShapes();\n\t//let annotation = _getAnnotation();\n\t//let uploads = _getUploadedFiles();\n\t//testing shape intersections and determine what to do with them\n\tconst shapeIntersections = await maptaskrControl.getShapeIntersections();\n\tif (shapeIntersections && shapeIntersections.length > 0) {\n\t\tif (shapeIntersections.some((res) => res.intersectionType == \'Warning\')) {\n\t\t\t//decide what to do with warnings\n\t\t\t//if you want them resolved, throw an error here..\n\t\t\t//throw new Error(onIntersectionMessage);\n\t\t}\n\t\tif (shapeIntersections.some((res) => res.intersectionType == \'Error\')) {\n\t\t\t//decide what to do with warnings\n\t\t\t//if you want them resolved, throw an error here..\n\t\t\tthrow new Error(onIntersectionMessage);\n\t\t}\n\t\tif (shapeIntersections.some((res) => res.intersectionType == \'Exclusion\')) {\n\t\t\t//decide what to do with warnings\n\t\t\t//if you want them resolved, throw an error here..\n\t\t\tthrow new Error(onIntersectionMessage);\n\t\t}\n\t}\n\n\t//you can also test to make sure your shapes are in the correct position, orintation, contained within eachother, any geometric tests here.\n\n\t//shapes will come in the format:\n\t// {\n\t//   "type": "FeatureCollection",\n\t//   "features": [\n\t//     {\n\t//       "type": "Feature",\n\t//       "geometry": {\n\t//         "type": "Polygon",\n\t//         "coordinates": [\n\t//           [\n\t//             [\n\t//               12899598.276481498,\n\t//               -3758060.96802893\n\t//             ],\n\t//      ...\n\t//           ]\n\t//         ]\n\t//       },\n\t//       "properties": {\n\t//         "uploadDocType": "Envelope",\n\t//         "markerType": "MARKER_SHAPE"\n\t//       }\n\t//     }\n\t//   ],\n\t//   "DocumentType": "Envelope",\n\t//   "annotationId": "1ffb72d6-c7c3-ed11-83fd-002248e1bcf1",\n\t//   "longlat": [\n\t//     12899440.776481498,\n\t//     -3758143.46802893\n\t//   ],\n\t//   "styleProperty": {\n\t//     "geometry_": null,\n\t//     "fill_": {\n\t//       "color_": "rgba(149,255,0,0.1)"\n\t//     },\n\t//  ...\n\t//   }\n\t// }\n\n\t//if you require a specific subset of objects, please look into the shapes, annotations, or uploads to ensure specific number of shapes or named shapes are included.\n}\n\nif (globalThis && globalThis.top) {\n\tglobalThis.top.maptaskrReady = function (pageContext, controlId) {\n\t\tconsole.log(\'Maptaskr Map ID: \' + controlId + \' has Loaded\');\n\n\t\tlet maptaskrControl = globalThis && globalThis.top && globalThis.top.maptaskrCORE && globalThis.top.maptaskrCORE[controlId];\n\n\t\tif (maptaskrControl) {\n\t\t\t/* Use the following console logs to uniquely identify your map */\n\t\t\t// console.log(pageContext);\n\t\t\t// console.log(maptaskrControl.registeredLocation);\n\t\t\t// console.log(maptaskrControl.webresourceLocation);\n\n\t\t\t/* register the correct client validation function here */\n\t\t\tmaptaskrControl.clientValidationFunction = clientValidationFunction;\n\n\t\t\t/* put your setup methods here */\n\t\t\t/* e.g. maptaskrControl.disableSaving = true; - this will disable the inbuilt save methods, you an use maptaskrControl.saveShapes() to save your own shapes.*/\n\n\t\t\t/* put your event registrations here. */\n\t\t\t/*  e.g. maptaskrControl.on("featuresSelected", ...) */\n\t\t}\n\t};\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now at the top of the file, let's declare a function called ",(0,o.jsx)(t.code,{children:"handleSelectedFeature"}),". This function will be called when a feature is selected and will target the appropriate HTML element to find a given attribute property and also render a custom button with its own ",(0,o.jsx)(t.code,{children:"onclick"})," function that will convert the ",(0,o.jsx)(t.code,{children:"featureArray"})," passed from the ",(0,o.jsx)(t.code,{children:"FeaturesSelected"})," event and call ",(0,o.jsx)(t.code,{children:"addSearchPolygon"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["In the example code below, we are specifically targetting an attribute property called ",(0,o.jsx)(t.code,{children:"tenid"}),". This will may not exist in the layer you are using so please adjust your code accordingly."]})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"let layerAttributePanelWatcher;\n\nfunction handleSelectedFeature(controlId, features) {\n    return new Promise((resolve, reject) => {\n        let maptaskrControl = globalThis && globalThis.top && globalThis.top.maptaskrCORE && globalThis.top.maptaskrCORE[controlId];\n\n        // Return early if maptaskrControl is not available\n        if (!maptaskrControl) {\n            console.error('maptaskrControl not found.');\n            reject();\n        }\n\n        // Set a timeout for 10 seconds to find the sidebar content and disable the interval if it fails\n        setTimeout(() => {\n            console.warn('.sidebar-content-right not found within 10 seconds.');\n            clearInterval(layerAttributePanelWatcher);\n            reject();\n        }, 10000);\n\n        clearInterval(layerAttributePanelWatcher);\n        layerAttributePanelWatcher = setInterval(() => {\n            let sidenavContent = document.querySelector('.sidebar-content-right');\n            // If .sidebar-content-right is found and visible, proceed\n            if (sidenavContent && !sidenavContent.classList.contains('ng-hide')) {\n                // Remove existing button if it exists\n                let existingButton = sidenavContent.querySelector('#selectProperty');\n                if (existingButton) {\n                    existingButton.remove();\n                }\n                \n                // Check for 'tenid' in the sidebar content\n                let tenid = null;\n                // Ensure rows exist\n                tenid = findTenidInsideAttributeTable(sidenavContent);\n               \n                // Ensure tenid is found before proceeding\n                if (!tenid) {\n                    console.warn('tenid not found in sidebar content.');\n                    reject();\n                }\n\n                // Find the feature that matches the 'tenid'\n                const selectedFeature = features.find(feature =>\n                    feature.attributes?.some(attr => {\n                        return attr.Text === 'tenid' && String(attr.Value).trim() === String(tenid).trim();\n                    })\n                );\n\n                // Only proceed if a matching feature is found\n                if (selectedFeature) {\n\n                    createButton(sidenavContent, selectedFeature, maptaskrControl);\n\n                    // Resolve the promise when the button is created and ready\n                    clearInterval(layerAttributePanelWatcher);\n                    resolve();\n                } else {\n                    console.warn('No matching feature found for tenid: ' + tenid);\n                    reject('No matching feature found for tenid');\n                }\n            }\n        }, 100); // Check every 100ms\n    });\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Next, we need to add a function called ",(0,o.jsx)(t.code,{children:"findTenIdInsideAttributeTable"})," that will iterate through the attribute pop-up table and find the ",(0,o.jsx)(t.code,{children:"tenid"})," row and return the value. We can use this to determine if the attribute pop-up is eligible to render the button, as well as generally retrieving the ",(0,o.jsx)(t.code,{children:"tenid"})," value."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function findTenidInsideAttributeTable(sidenavContent) {\n    let tenid = null;\n    let rows = sidenavContent.querySelectorAll('table tr');\n    if(rows.length === 0) return tenid;\n    rows.forEach((row) => {\n        let cells = row.querySelectorAll('td');\n        if (cells.length > 1) {\n            if (cells[0].textContent.trim() === 'tenid') {\n                tenid = cells[1].textContent.trim();\n            }\n        }\n    });\n    return tenid;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's add a function called ",(0,o.jsx)(t.code,{children:"createButton"})," that will be responsible for generating the button, its ",(0,o.jsx)(t.code,{children:"onclick"})," logic and also retrieving the ",(0,o.jsx)(t.code,{children:"tenid"})," value one more time to prevent accidentally picking up an old value in the case where you are continuously clicking on layer features without closing the attribute pop-up."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"addSearchPolygon"})," supports coordinates in either EPSG:3857 or EPSG:4326.\nWe are passing ",(0,o.jsx)(t.code,{children:"true"})," as a second parameter when calling ",(0,o.jsx)(t.code,{children:"addSearchPolygon"})," because the coordinates returned by the ",(0,o.jsx)(t.code,{children:"FeaturesSelected"})," function are in the EPSG:3857 coordinate system.\nIf you are going to use the ",(0,o.jsx)(t.code,{children:"addSearchPolygon"})," function separately and have coordinates in the EPSG:4326 coordinate system, you will need to pass ",(0,o.jsx)(t.code,{children:"false"})," as the second parameter to ensure that the data is correctly transformed."]})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function createButton(sidenavContent, selectedFeature, maptaskrControl)\n{\n    // Create the button element\n    let button = document.createElement('button');\n    button.id = 'selectProperty';\n    button.className = 'btn btn-primary';\n    button.type = 'button';\n    button.style.backgroundColor = 'var(--main-colour)';\n    button.style.padding = '10px';\n    button.style.margin = '10px';\n    button.style.width = 'calc(100% - 20px)';\n    button.style.fontSize = '14px';\n    button.textContent = 'Add Polygon to Search';\n    // Set the button's click event\n    button.onclick = function (event) {\n        event.preventDefault(); // Prevent default behavior\n\n        // Regrab the latest tenid from the element, in case it has changed\n        let tenid = findTenidInsideAttributeTable(sidenavContent);\n\n        // Proceed only if tenid is found\n        if (!tenid) {\n            return;\n        }\n\n        // Perform the action with the tenid\n        const geoJson = findAndConvertToGeoJSON(selectedFeature);\n        maptaskrControl.addSearchPolygon(geoJson, true);\n    };\n\n    // Add the button to the sidenav content\n    let targetDiv = document.querySelector(\".sidebar-content-right .sidebar-section table\");\n    if (targetDiv) {\n        targetDiv.insertBefore(button, targetDiv.firstChild);\n    }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Lastly, let's add another function called ",(0,o.jsx)(t.code,{children:"findAndConvertToGeoJSON"}),". This function will accept the ",(0,o.jsx)(t.code,{children:"selectedFeature"})," object that we extracted inside the ",(0,o.jsx)(t.code,{children:"addButtonToDialog"})," function, and convert it to a geoJSON object that the ",(0,o.jsx)(t.code,{children:"addSearchPolygon"})," function requires."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'function findAndConvertToGeoJSON(selectedFeature) {\n\n    const geometryString = selectedFeature.geometry.geometry; // Geometry as a string\n    const coordinatesArray = geometryString.split(",").map(Number); // Split string and convert to numbers\n\n    // Helper to group flat array into coordinate pairs\n    const groupCoordinates = (flatArray) => {\n        const coordinates = [];\n        for (let i = 0; i < flatArray.length; i += 2) {\n            coordinates.push([flatArray[i], flatArray[i + 1]]);\n        }\n        return coordinates;\n    };\n\n    // Group coordinates into pairs\n    const groupedCoordinates = groupCoordinates(coordinatesArray);\n\n    // Split polygons based on closure (first and last coordinates matching)\n    const polygons = [];\n    let currentPolygon = [];\n\n    groupedCoordinates.forEach((coordinate) => {\n        currentPolygon.push(coordinate);\n        // If the current polygon is closed (first equals last), start a new one\n        if (currentPolygon.length > 1 &&\n            coordinate[0] === currentPolygon[0][0] &&\n            coordinate[1] === currentPolygon[0][1]) {\n            polygons.push(currentPolygon);\n            currentPolygon = [];\n        }\n    });\n\n\n    // Construct GeoJSON\n    const geoJSON = {\n        type: "Feature",\n        properties: {},\n        geometry: {\n            type: polygons.length > 1 ? "MultiPolygon" : "Polygon",\n            coordinates: polygons.length > 1 ? polygons.map(coords => [coords]) : [polygons[0]]\n        }\n    };\n\n    return geoJSON;\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"Let's see this code in action!"}),"\n",(0,o.jsxs)(t.p,{children:["What a layer feature is selected, an attribute pop-up appears on the right-hand side of the screen and we should see our custom button appear on the top (as long as the layer meets our requirements of containing a ",(0,o.jsx)(t.code,{children:"tenid"})," attribute property). Clicking this button should generate a polygon, and switch our Search panel tab to ",(0,o.jsx)(t.code,{children:"Draw"}),". Executing search will now use this polygon as part of the search area."]}),"\n",(0,o.jsxs)(t.p,{children:["Below is a gif demonstrating this functionality:\n",(0,o.jsx)(t.img,{src:n(77485).A+"",width:"1824",height:"1268"})]}),"\n",(0,o.jsxs)(t.p,{children:["Success! Using the code snippets above we have successfully listened to the ",(0,o.jsx)(t.code,{children:"FeaturesSelected"})," event and extended its capability to convert the geometry to a geoJSON object, generate a button and call the ",(0,o.jsx)(t.code,{children:"addSearchPolygon"})," function to add the geometry to our search area."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},77485:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/demonstration-6e2bd8e1f4d33f58fa1232558d00b4e2.gif"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(96540);const r={},a=o.createContext(r);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);
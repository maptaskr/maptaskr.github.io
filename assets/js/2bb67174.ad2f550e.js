"use strict";(self.webpackChunkmaptaskr_docs_copy=self.webpackChunkmaptaskr_docs_copy||[]).push([[3510],{62706:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(74848),i=t(28453);const o={title:"Power Pages | Installation Guide | Appendix B: Custom JavaScript",sidebar_label:"Appendix B: Custom Javascript"},r="Appendix B: Custom JavaScript",s={id:"power-pages/installation-guide/appendix-b-custom-javascript",title:"Power Pages | Installation Guide | Appendix B: Custom JavaScript",description:"Initmap.js",source:"@site/docs/power-pages/installation-guide/appendix-b-custom-javascript.md",sourceDirName:"power-pages/installation-guide",slug:"/power-pages/installation-guide/appendix-b-custom-javascript",permalink:"/docs/power-pages/installation-guide/appendix-b-custom-javascript",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Power Pages | Installation Guide | Appendix B: Custom JavaScript",sidebar_label:"Appendix B: Custom Javascript"},sidebar:"maptaskrSidebar",previous:{title:"Appendix A: Web Templates",permalink:"/docs/power-pages/installation-guide/appendix-a-web-templates"},next:{title:"Introduction",permalink:"/docs/power-pages/registerable-events/introduction"}},l={},d=[{value:"Initmap.js",id:"initmapjs",level:2},{value:"Form Submit Button",id:"form-submit-button",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",pre:"pre",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"appendix-b-custom-javascript",children:"Appendix B: Custom JavaScript"}),"\n",(0,a.jsx)(e.h2,{id:"initmapjs",children:"Initmap.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'/* \n * VARIABLES FOR THE INITMAPS\n */\nconst maptaskrEntityDefinition = [\n    {\n        pathName: "create-case", //url of the page the PCF control is loaded on\n        relationshipName: "contoso_Incident", //case sensitive, recommended to use the lookup field logical name \n        entityName: "incident", //case sensitive, recommended to use the lookup field logical name\n        entityPluralName: "incidents" //case sensitive\n    },\n    {\n        pathName: "edit-case", //url of the page the PCF control is loaded on\n        relationshipName: "contoso_Incident", //case sensitive, recommended to use the lookup field logical name \n        entityName: "incident", //case sensitive, recommended to use the lookup field logical name \n        entityPluralName: "incidents" //case sensitive\n    },\n    {\n        pathName: "account", //url of the page the PCF control is loaded on\n        relationshipName: "maptaskr_Account", //case sensitive, recommended to use the lookup field logical name \n        entityName: "account", //case sensitive, recommended to use the lookup field logical name \n        entityPluralName: "accounts" //case sensitive\n    }\n]\nconst onValidateFailErrorMessage = \'Please upload a file or draw a shape\'; //error message to display when the map validation errors\nconst onUploadFailErrorMessage = \'Something has gone wrong during submission, please check your connection and try again.\';\nconst onIntersectionMessage = \'Intersections / Exclusions have been found, please check your shapes and try again.\';\n\nconst clientValidationFunction = async() => {\n    //user defined validation function, can use the following for getting the list of shapes, annotations and uploaded files.\n    //if the user needs to fix the shapes, throw an error.\n    \n    //let shapes = _getShapes();\n    //let annotation = _getAnnotation();\n    //let uploads = _getUploadedFiles();\n\n    //testing shape intersections and determine what to do with them\n    const shapeIntersections = await _getShapeIntersections();\n    if (shapeIntersections && shapeIntersections.length > 0){\n\n        if (shapeIntersections.some(res => res.intersectionType == \'Warning\'))\n        {\n            //decide what to do with warnings\n            //if you want them resolved, throw an error here..\n            //throw new Error(onIntersectionMessage);\n        }\n        if (shapeIntersections.some(res => res.intersectionType == \'Error\'))\n        {\n            //decide what to do with warnings\n            //if you want them resolved, throw an error here..\n            throw new Error(onIntersectionMessage);\n        }\n        if (shapeIntersections.some(res => res.intersectionType == \'Exclusion\'))\n        {\n            //decide what to do with warnings\n            //if you want them resolved, throw an error here..\n            throw new Error(onIntersectionMessage);\n        }\n    }\n\n    //you can also test to make sure your shapes are in the correct position, orintation, contained within eachother, any geometric tests here.\n\n    //shapes will come in the format:\n    // {\n    //   "type": "FeatureCollection",\n    //   "features": [\n    //     {\n    //       "type": "Feature",\n    //       "geometry": {\n    //         "type": "Polygon",\n    //         "coordinates": [\n    //           [\n    //             [\n    //               12899598.276481498,\n    //               -3758060.96802893\n    //             ],\n    //      ...\n    //           ]\n    //         ]\n    //       },\n    //       "properties": {\n    //         "uploadDocType": "Envelope",\n    //         "markerType": "MARKER_SHAPE"\n    //       }\n    //     }\n    //   ],\n    //   "DocumentType": "Envelope",\n    //   "annotationId": "1ffb72d6-c7c3-ed11-83fd-002248e1bcf1",\n    //   "longlat": [\n    //     12899440.776481498,\n    //     -3758143.46802893\n    //   ],\n    //   "styleProperty": {\n    //     "geometry_": null,\n    //     "fill_": {\n    //       "color_": "rgba(149,255,0,0.1)"\n    //     },\n    //  ...\n    //   }\n    // }\n    \n    //if you require a specific subset of objects, please look into the shapes, annotations, or uploads to ensure specific number of shapes or named shapes are included.\n}\n/*\n * STOP EDITING HERE - Unless you require customized validation and saving functionality.\n *\n *\n */\n\n(function (webapi, $) {\n    function safeAjax(ajaxOptions) {\n        var deferredAjax = $.Deferred();\n        shell.getTokenDeferred().done(function (token) {\n            // add headers for AJAX\n            if (!ajaxOptions.headers) {\n                $.extend(ajaxOptions, {\n                    headers: {\n                        "__RequestVerificationToken": token\n                    }\n                });\n            } else {\n                ajaxOptions.headers["__RequestVerificationToken"] = token;\n            }\n            $.ajax(ajaxOptions)\n                .done(function (data, textStatus, jqXHR) {\n                    validateLoginSession(data, textStatus, jqXHR, deferredAjax.resolve);\n                }).fail(deferredAjax.reject); //AJAX\n        }).fail(function () {\n            deferredAjax.rejectWith(this, arguments); // on token error pass the token AJAX and args\n        });\n        return deferredAjax.promise();\n    }\n    webapi.safeAjax = safeAjax;\n})(window.webapi = window.webapi || {}, jQuery);\n\n//helpers to get the current entity and id\nfunction _getCurrentEntityName() {\n    var currentPageEntity = maptaskrEntityDefinition.filter((x) => window.location.pathname.includes(x.pathName));\n\n    if (currentPageEntity.length == 1)\n        return currentPageEntity[0];\n\n    return { pathname: null, entityPluralName: null };\n}\nfunction _getParentId(checkProposal) {\n    var url = new URL(window.location.href);\n    const urlSearchParams = new URLSearchParams(url.search);\n    var parentId = $("#EntityFormView_EntityID").val();\n    if (checkProposal) {\n        var recordId = $("#id").val();\n    }\n    if (recordId != null || recordId != undefined) { parentId = recordId; }\n    if (!parentId) { //if you want to use custom query params to read ID of the record\n        var parentId = urlSearchParams.get("id");\n    }\n    return parentId;\n}\n\n\n//VALIDATE SHAPE CONTENT\nasync function validateAnnotationsAndShapes() {\n    window.maptaskrPCF.handleLoadingSpinner(true, "Validating shape...");\n    try {\n        await clientValidationFunction();\n        return true;\n    }\n    catch(err) {\n        showPortalWarning(err);\n    }\n    return false;\n}\n//SAVE CONTENT\nfunction saveAnnotationsAndShapes() {\n    return new Promise(async (resolve, reject) => {\n        var parentId = _getParentId(false);\n        try {\n            let clientValidationSuccess = await validateAnnotationsAndShapes();\n            if (clientValidationSuccess)\n            {\n                window.maptaskrPCF.handleLoadingSpinner(true, "Saving shape...");\n                //if we have any lambpetIds - we have already loaded objects.\n                if (_getShapeLambpetIds() && _getShapeLambpetIds().length > 0) {\n                    await _deleteRemovedShapes();\n                }\n                await _addNewShapes(parentId);\n                resolve();\n            }\n            else\n            {\n                reject();\n            }\n        } catch (err) {\n            showPortalWarning(onUploadFailErrorMessage);\n            reject(err)\n        }\n    });\n}\n\n//functions for deleting, adding, and creating in D365.\nfunction _deleteRemovedShapes() {\n    return new Promise(async (resolve, reject) => {\n        var remainingShapes = _getShapes();\n        var remainingAnnotation = _getAnnotation();\n        var lambpets = _getShapeLambpetIds();\n\n        for (var i = 0; i < lambpets.length; i++) {\n            var existingAnnotationId = lambpets[i].id.split("___")[1]; //used in comparison against existing shapes\n            let existingLambpetId = lambpets[i].id.split("___")[0]; //used in the delete functionality\n            let existingShapeName = lambpets[i].name;\n            if (existingAnnotationId) {\n                try {\n                    let shapeStillExists = false;\n\n                    //if the user has deleted this lambpet... remove it from the system\n                    if (remainingShapes && remainingShapes.filter((s)=> s.annotationId == existingAnnotationId)?.length > 0)\n                    {\n                        shapeStillExists = true;\n                    }\n\n                    //if the user has deleted this lambpet... remove it from the system\n                    if (remainingAnnotation && remainingAnnotation.annotationId == existingAnnotationId)\n                    {\n                        shapeStillExists = true;\n                    }\n\n                    if (!shapeStillExists)\n                    {\n                        setProgressDialogMessage(`Deleting existing \'${existingShapeName}\'...`);\n                        await webapi.safeAjax({\n                            type: "DELETE",\n                            url: `/_api/maptaskr_lambpets(${existingLambpetId})`,\n                            contentType: "application/json",\n                        });\n                        window.maptaskrPCF.fire("LambpetDeleted", existingLambpetId);\n                    }\n                } catch (err) {\n                    reject(err);\n                }\n            }\n        }\n        //if we get through all shapes to be deleted, and succeed.\n        resolve();\n    });\n}\nasync function _addNewShapes(parentId){\n    try{\n        await _addLambpets(parentId, _getShapes(true), true); //add shapes (as children)\n        \n        //if (annotation is new)\n        let annotation = _getAnnotation();\n        if (annotation && annotation.annotationId == null)\n        {\n            await _addLambpet(parentId, annotation, false); //add the NEW annotations as D365\n        }\n        await _attachOriginalFilesToEntity(parentId, _getUploadedFiles());\n        return;\n    }catch(err){\n        throw err;\n    }\n}\n\nfunction _addLambpets(entityId, areas) {\n    var promises = [];\n    for (var i = 0; i < areas.length; i++) {\n        promises.push(_addLambpet(entityId, areas[i]));\n    }\n    return Promise.all(promises);\n}\nfunction _addLambpet(parentId, area, isChildShape = true) {\n    var tableNames = _getCurrentEntityName();\n    var data = {\n        "maptaskr_name": area.DocumentType,\n        "maptaskr_parententityid": parentId,\n        "maptaskr_json": area.styleProperty ? JSON.stringify(area.styleProperty) : "null",\n        "maptaskr_ischild": isChildShape,\n        "maptaskr_longitude": area.longlat[0],\n        "maptaskr_latitude": area.longlat[1],\n    };\n    data[`${tableNames.relationshipName}@odata.bind`] = `/${tableNames.entityPluralName}(${parentId})`;\n    setProgressDialogMessage(`Adding new \'${area.DocumentType}\'...`);\n    return new Promise((resolve, reject) => {\n        webapi.safeAjax({\n            type: "POST",\n            url: "/_api/maptaskr_lambpets",\n            contentType: "application/json",\n            data: JSON.stringify(data),\n            success: function (res, status, xhr) {\n                var lambpetId = xhr.getResponseHeader("entityid");\n                window.maptaskrPCF.fire("LambpetCreated", lambpetId, JSON.stringify(data));\n                _createAnnotation(lambpetId, JSON.stringify(area), area).then(() => {\n                    resolve();\n                }).catch((err) => {\n                    reject(err);\n                });\n            },\n            error: function () {\n                reject();\n            }\n        });\n    });\n\n}\nfunction _createAnnotation(parentId, geojson, rawgeojson) {\n    var data = {\n        filename: rawgeojson.DocumentType,\n        mimetype: "geojson",\n        documentbody: strToBase64(geojson),\n        objecttypecode: "maptaskr_lambpet",\n        subject: rawgeojson.DocumentType\n    };\n    data["objectid_maptaskr_lambpet@odata.bind"] =\n        "/maptaskr_lambpets(" + parentId + ")";\n    return new Promise((resolve, reject) => {\n        webapi.safeAjax({\n        type: "POST",\n        url: "/_api/annotations",\n        contentType: "application/json",\n        data: JSON.stringify(data),\n        success: function (res, status, xhr) {\n                var annotationId = xhr.getResponseHeader("entityid");\n                window.maptaskrPCF.fire("AnnotationCreated", annotationId, JSON.stringify(data));\n                resolve();\n            },\n            error: function () {\n                reject();\n            }\n        });\n    });\n}\nfunction _createAnnotationForParent(parentId, utf8encodedFile, file) {\n    var tableNames = _getCurrentEntityName();\n    var data = {\n        filename: `${file.name}`,\n        mimetype: `${file.type}`,\n        documentbody: window.btoa(utf8encodedFile),\n        objecttypecode: `${tableNames.entityName}`,\n    };\n    data[`objectid_${tableNames.entityName}@odata.bind`] = `/${tableNames.entityPluralName}(${parentId})`;\n    return  new Promise((resolve, reject) => {\n        webapi.safeAjax({\n            type: "POST",\n            url: "/_api/annotations",\n            contentType: "application/json",\n            data: JSON.stringify(data),\n            success: function (res, status, xhr) {\n                var annotationId = xhr.getResponseHeader("entityid");\n                window.maptaskrPCF.fire("OriginalFileUploaded", annotationId, JSON.stringify(data));\n                resolve();\n            },\n            error: function () {\n                reject();\n            }\n        });\n    });\n}\nfunction _attachOriginalFilesToEntity(entityId, files) {\n    return new Promise(async (resolve, reject) => {\n        if (files.length == 0) {\n            resolve(); //resolve if no files as this function gets called regardless if there are files or not\n            return;\n        }\n        var uploadedOriginalShapes = 0;\n        for (var i = 0; i < files.length; i++) {\n            console.log(\'File\', files[i]);\n            var file = files[i];\n            if (file) {\n                try {\n                    var utf8DocBody = await _readFileAsBufferToUTF8(file);\n                    await _createAnnotationForParent(entityId, utf8DocBody, file);\n                    uploadedOriginalShapes++;\n                } catch (err) {\n                    reject(err);\n                    return;\n                }\n            }\n        }\n        if (uploadedOriginalShapes == files.length) {\n            resolve();\n        } else {\n            reject();\n        }\n    });\n}\n\n//Region to get shapes, annotations and files from the PCF.\nfunction _getShapeLambpetIds() {\n    return window.maptaskrPCF.getLambpetIds();\n}\nfunction _getShapes(getNewShapesOnly = false) {\n    let uploadedPolygons = window.maptaskrPCF.getUploadedShapes();\n    let drawnPolygons = window.maptaskrPCF.getDrawnShapes();\n\n    let shapes = [];\n    uploadedPolygons.forEach(element => {\n        if (!getNewShapesOnly || element.annotationId == null)\n            shapes.push(element);\n    });\n    drawnPolygons.forEach(element => {\n        if (!getNewShapesOnly || element.annotationId == null)\n            shapes.push(element);\n    });\n    return shapes;\n}\n\nfunction _getAnnotation() {\n    return window.maptaskrPCF.getAnnotation();\n}\nfunction _getUploadedFiles() {\n    return window.maptaskrPCF.getUploadedFiles();\n}\n\n// helper function for loading a file as a UTF8 array.\nfunction _readFileAsBufferToUTF8(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(_arrayBufferToUTF8(reader.result));\n        reader.readAsArrayBuffer(file);\n        reader.onerror = (error) => reject(error);\n    });\n}\nfunction _arrayBufferToUTF8(buffer) { // Convert Array Buffer to UTF8 string\n    var binary = \'\';\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n\n//ui helpers for showing warnings and enabling buttons.\nfunction showPortalWarning(msg) {\n    window.maptaskrPCF.showWarningMessage(msg, 5000);\n    $(\'html, body\').animate({\n        \'scrollTop\': $(\'.validation-map\').position().top\n    });\n}\nfunction enableButtons() {\n    var inputs = document.getElementsByTagName("input");\n    for (var i = 0, j = inputs.length; i < j; i++) {\n        if (inputs[i].type === \'submit\' || inputs[i].type === \'button\') {\n            inputs[i].disabled = false;\n        }\n    }\n}\n\nfunction _getShapeIntersections() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const response = await window.maptaskrPCF.getShapeIntersections();\n            resolve(response);\n        } catch {\n            reject();\n        }\n    });\n}\n\n//conversionHelper for the InitMap\n\nfunction strToBase64(str) {\n    return window.btoa(unescape(encodeURIComponent(str)))\n}\n\nfunction setProgressDialogMessage(message) {\n    window.maptaskrPCF.updateLoadingSpinnerMessage(message)\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"form-submit-button",children:"Form Submit Button"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'//id of the button to invoke save on.\nconst buttonId = "NextButton";\nlet button;\nlet buttonName;\n\nfunction validateAndSave() {\n\t//validate our shapes.\n\tvar buttonValue = \'\'\n\tclearIsDirty();\n\tdisableButtons();\n\tbuttonValue = button.value;\n\tbutton.value = \'Processing...\';\n\n\t//if our shapes validate, start the upload, and return "false" allowing the async process to continue.\n\t//async upload shape files \n\tsaveAnnotationsAndShapes().then(()=> {\n\t\t//once uploaded, skip validation and postback the button\n\t\t//invoke on the main thread.\n\t\tsetProgressDialogMessage("Saving complete!");\n\t\tsetTimeout(function () {\n\t\t\tWebForm_DoPostBackWithOptions(new WebForm_PostBackOptions(buttonName, "", true, "", "", false, true));\n\t\t}, 100);\n\t}).catch(() => {\n\t\tclearIsDirty();\n\t\tenableButtons();\n\t\tbutton.value = buttonValue;\n\t\twindow.maptaskrPCF.handleLoadingSpinner(false);\n\t});\n\treturn false;\n}\n//ADVANCED and BASIC combined\n//once the document is loaded\n$(document).ready(function () {\n\n\t//find the button and save the name for posting back the form\n\tbutton = document.getElementById(buttonId);\n\tbuttonName = button.getAttribute("name");\n\n\t//if there is already a webFormClientValidate function\n\tif (typeof (webFormClientValidate) == "function") {\n\t\t//save the original func\n\t\tvar baseValidationFunction = webFormClientValidate;\n\t\t//wrap it in out new method\n\t\twebFormClientValidate = function (arguments) {\n\t\t\t//apply the original webFormClientValidate function\n\t\t\tif (baseValidationFunction.apply(this, arguments)) {\n\t\t\t\tvalidateAndSave();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\twebFormClientValidate = validateAndSave;\n\t}\n\t\n\tif (typeof (entityFormClientValidate) == "function") {\n\t\t//save the original func\n\t\tvar baseValidationFunction = entityFormClientValidate;\n\t\t//wrap it in out new method\n\t\tentityFormClientValidate = function (arguments) {\n\t\t\t//apply the original webFormClientValidate function\n\t\t\tif (baseValidationFunction.apply(this, arguments)) {\n\t\t\t\tvalidateAndSave();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tentityFormClientValidate = validateAndSave;\n\t}\n});\n'})})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var a=t(96540);const i={},o=a.createContext(i);function r(n){const e=a.useContext(o);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);